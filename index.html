<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Виртуальный барабан — клавиатура, тач, MIDI, метроном, сохранение</title>
<style>
:root{
  --bg:#111; --panel:#222; --pad:#333; --accent:#ff5252; --muted:#666; --text:#eee;
}
html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:Inter,Segoe UI,Arial, sans-serif}
.container{max-width:980px;margin:18px auto;padding:12px}
.header{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
.title{font-size:20px;margin-right:8px}
.controls{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:12px}
.btn{background:var(--panel);border:1px solid #000;color:var(--text);padding:8px 10px;border-radius:8px;cursor:pointer}
.small{padding:6px 8px;font-size:13px}
.grid{display:grid;grid-template-columns:repeat(4,140px);gap:12px;margin-top:18px;justify-content:center}
.pad{width:140px;height:140px;background:var(--pad);border-radius:12px;display:flex;flex-direction:column;align-items:center;justify-content:center;cursor:grab;position:relative;box-shadow:0 6px rgba(0,0,0,0.6);user-select:none;touch-action:none}
.pad .code{font-weight:700;font-size:20px;margin-bottom:6px}
.pad .name{font-weight:600;font-size:13px;text-align:center;padding:0 6px}
.pad.playing{background:var(--accent);box-shadow:0 3px rgba(0,0,0,0.5);transform:translateY(3px)}
.upload{position:absolute;right:8px;bottom:8px;background:var(--muted);border:none;color:var(--text);padding:4px 7px;border-radius:6px;cursor:pointer;font-size:12px}
.pad.drag-over{outline:3px dashed var(--accent)}
.controls-row{display:flex;gap:10px;align-items:center}
.range{display:flex;align-items:center;gap:6px}
.info{margin-top:10px;color:#bbb;font-size:13px}
@media (max-width:640px){.grid{grid-template-columns:repeat(2,160px)}.pad{width:160px;height:160px}}
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <div class="title">Drumzy</div>
    <div style="margin-left:auto;color:#bbb;font-size:20px">by SkaldSaga</div>
  </div>

  <div class="controls">
    <div class="controls-row">
      <button id="unlockBtn" class="btn small">Разблокировать аудио</button>
      <button id="midiBtn" class="btn small">Подключить MIDI</button>
      <label style="display:flex;align-items:center;gap:6px;color:#bbb;font-size:13px">
        <input id="midiLog" type="checkbox"> MIDI монитор
      </label>
    </div>

    <div class="controls-row" style="margin-left:8px">
      <div class="range"><label for="bpm">BPM</label><input id="bpm" type="range" min="40" max="240" value="120"></div>
      <div style="min-width:44px;text-align:center" id="bpmLabel">120</div>
      <div class="range"><label for="metroVol">Vol</label><input id="metroVol" type="range" min="0" max="1" step="0.01" value="0.5"></div>
      <button id="metroToggle" class="btn small">Start Metronome</button>
    </div>
  </div>

  <div class="info" id="status">Статус: готов — кликни «Разблокировать аудио», затем играй мышью, клавиатурой или MIDI.</div>

  <div class="grid" id="grid"></div>

  <div class="info" id="midiLogBox" style="display:none;margin-top:8px;max-height:120px;overflow:auto;background:#0f0f0f;padding:8px;border-radius:6px;color:#ccc;font-size:13px"></div>
</div>

<script>
/* ---------------------- Конфигурация / Звуки ---------------------- */
/* Базовая раскладка — позиция (index) привязана к code (e.code),
   code НЕ меняется при перетаскивании — меняем только sound+name.
   При перезапуске сохраняется массив padState в localStorage.
*/
const defaultPads = [
  { code:'KeyQ', sound:'kick', name:'Kick' },
  { code:'KeyW', sound:'snare', name:'Snare' },
  { code:'KeyE', sound:'hihat', name:'Hi-Hat' },
  { code:'KeyR', sound:'hihat_open', name:'Hi-Hat Open' },
  { code:'KeyA', sound:'clap', name:'Clap' },
  { code:'KeyS', sound:'tom1', name:'Tom 1' },
  { code:'KeyD', sound:'tom2', name:'Tom 2' },
  { code:'KeyF', sound:'tom3', name:'Tom 3' },
  { code:'KeyZ', sound:'ride', name:'Ride' },
  { code:'KeyX', sound:'crash', name:'Crash' },
  { code:'KeyC', sound:'shaker', name:'Shaker' },
  { code:'KeyV', sound:'cowbell', name:'Cowbell' },
  { code:'Digit1', sound:'snap', name:'Snap' },
  { code:'Digit2', sound:'perc1', name:'Perc 1' },
  { code:'Digit3', sound:'perc2', name:'Perc 2' },
  { code:'Digit4', sound:'clave', name:'Clave' }
];

/* Пути к звуковым файлам в папке sounds/ (положи файлы рядом с index.html) */
const soundFiles = {
  kick: 'sounds/kick.wav',
  snare: 'sounds/snare.wav',
  hihat: 'sounds/hihat.wav',
  hihat_open: 'sounds/hihat_open.wav',
  clap: 'sounds/clap.wav',
  tom1: 'sounds/tom1.wav',
  tom2: 'sounds/tom2.wav',
  tom3: 'sounds/tom3.wav',
  ride: 'sounds/ride.wav',
  crash: 'sounds/crash.wav',
  shaker: 'sounds/shaker.wav',
  cowbell: 'sounds/cowbell.wav',
  snap: 'sounds/snap.wav',
  perc1: 'sounds/perc1.wav',
  perc2: 'sounds/perc2.wav',
  clave: 'sounds/clave.wav'
};

/* ---------------------- state и сохранение ---------------------- */
const STORAGE_KEY = 'virtual_drum_pads_v1';
let padState = loadState() || defaultPads.slice();
function loadState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return null;
    const obj = JSON.parse(raw);
    if(!Array.isArray(obj) || obj.length !== 16) return null;
    return obj;
  } catch(e){ console.warn('loadState err', e); return null; }
}
function saveState(){
  try{
    localStorage.setItem(STORAGE_KEY, JSON.stringify(padState));
    statusText('Состояние сохранено');
  } catch(e){ console.warn('saveState err', e); }
}

/* ---------------------- DOM генерация падов ---------------------- */
const grid = document.getElementById('grid');
const status = document.getElementById('status');
const midiLogBox = document.getElementById('midiLogBox');

function displayKey(code){ return code.replace(/^(Key|Digit)/,''); }

function renderPads(){
  grid.innerHTML = '';
  padState.forEach((p, idx) => {
    const div = document.createElement('div');
    div.className = 'pad';
    div.draggable = true;
    div.dataset.index = idx;
    div.dataset.code = p.code;
    div.dataset.sound = p.sound;
    div.innerHTML = `<div class="code">${displayKey(p.code)}</div><div class="name">${p.name}</div><button class="upload">+</button>`;
    grid.appendChild(div);
  });
}
renderPads();

/* ---------------------- Preload звуков ---------------------- */
const audioMap = {}; // id -> HTMLAudioElement
for(const id in soundFiles){
  const a = document.createElement('audio');
  a.src = soundFiles[id];
  a.preload = 'auto';
  audioMap[id] = a;
}
// note: user-uploaded audio will be stored in audioMap with id 'user_xxx' for session only

/* Воспроизведение (клонируем элемент для полифонии) */
function playSound(id, velocity=127){
  const base = audioMap[id];
  if(!base){
    console.warn('Sound not found:', id);
    return;
  }
  try{
    const a = base.cloneNode(true);
    a.volume = Math.min(1, Math.max(0, velocity/127));
    a.currentTime = 0;
    a.play().catch(()=>{/* may be blocked until user interaction */});
  }catch(e){ console.error(e); }
}

/* Вызов по позиции/индексу */
function triggerByIndex(index, velocity=127){
  const pad = document.querySelector(`.pad[data-index="${index}"]`);
  if(!pad) return;
  const soundId = pad.dataset.sound;
  flashPad(pad);
  playSound(soundId, velocity);
}
function flashPad(pad){
  pad.classList.add('playing');
  setTimeout(()=>pad.classList.remove('playing'),150);
}

/* ---------------------- Click / Touch / Upload ---------------------- */
grid.addEventListener('pointerdown', e=>{
  const pad = e.target.closest('.pad');
  if(!pad) return;
  if(e.target.classList.contains('upload')){
    openUploadDialog(pad);
    return;
  }
  const idx = Number(pad.dataset.index);
  triggerByIndex(idx);
});

/* Upload custom sound to pad (session only) */
function openUploadDialog(pad){
  const idx = Number(pad.dataset.index);
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = 'audio/*';
  input.onchange = (ev) => {
    const f = ev.target.files[0];
    if(!f) return;
    const url = URL.createObjectURL(f);
    const id = 'user_' + Math.random().toString(36).slice(2,9);
    const a = document.createElement('audio'); a.src = url; a.preload = 'auto';
    audioMap[id] = a;
    // назначаем pad на этот звук (sound id = id), сохраняем имя (файл)
    padState[idx].sound = id;
    padState[idx].name = f.name.replace(/\.[^.]+$/,'');
    saveState(); // сохраняем info о user id - но сам URL не восстановится после перезагрузки
    renderPads();
  };
  input.click();
}

/* ---------------------- Keyboard (e.code) ---------------------- */
window.addEventListener('keydown', e=>{
  if(e.repeat) return;
  const pad = document.querySelector(`.pad[data-code="${e.code}"]`);
  if(pad) triggerByIndex(Number(pad.dataset.index));
});

/* ---------------------- Drag & Drop: swap sound+name ---------------------- */
let dragPayload = null;
grid.addEventListener('dragstart', e=>{
  const pad = e.target.closest('.pad');
  if(!pad) return;
  const idx = Number(pad.dataset.index);
  dragPayload = { index: idx, sound: pad.dataset.sound, name: pad.querySelector('.name').textContent };
  try{ e.dataTransfer.setData('application/json', JSON.stringify(dragPayload)); }catch(_){}
  pad.classList.add('dragging');
});
grid.addEventListener('dragend', e=>{
  const p = e.target.closest('.pad');
  if(p) p.classList.remove('dragging');
});
grid.addEventListener('dragover', e=>{
  e.preventDefault();
  const p = e.target.closest('.pad'); if(p) p.classList.add('drag-over');
});
grid.addEventListener('dragleave', e=>{
  const p = e.target.closest('.pad'); if(p) p.classList.remove('drag-over');
});
grid.addEventListener('drop', e=>{
  e.preventDefault();
  const tgt = e.target.closest('.pad'); if(!tgt || !dragPayload) return;
  tgt.classList.remove('drag-over');
  let payload = dragPayload;
  try{
    const dt = e.dataTransfer.getData('application/json');
    if(dt) payload = JSON.parse(dt);
  }catch(_){}
  const srcIdx = payload.index;
  const tgtIdx = Number(tgt.dataset.index);
  if(srcIdx === tgtIdx){ dragPayload = null; return; }
  // swap sound+name between src and tgt (codes stay on positions)
  const src = padState[srcIdx];
  const tgtState = padState[tgtIdx];
  const tmpSound = src.sound, tmpName = src.name;
  src.sound = tgtState.sound; src.name = tgtState.name;
  tgtState.sound = tmpSound; tgtState.name = tmpName;
  saveState();
  renderPads();
  dragPayload = null;
});

/* ---------------------- AudioContext unlock & Metronome ---------------------- */
let audioCtx = null;
function ensureAudioCtx(){
  if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if(audioCtx.state === 'suspended') audioCtx.resume();
  return audioCtx;
}

document.getElementById('unlockBtn').addEventListener('click', async ()=>{
  try{
    const ctx = ensureAudioCtx();
    const osc = ctx.createOscillator();
    const g = ctx.createGain();
    g.gain.value = 0.0001;
    osc.connect(g); g.connect(ctx.destination);
    osc.start(); osc.stop(ctx.currentTime + 0.02);
    statusText('Аудио разблокировано');
  }catch(e){ console.warn(e); statusText('Ошибка разблокировки аудио'); }
});

/* Метроном */
const bpmSlider = document.getElementById('bpm');
const bpmLabel = document.getElementById('bpmLabel');
const metroVol = document.getElementById('metroVol');
const metroToggle = document.getElementById('metroToggle');
let metroTimer = null;
bpmSlider.addEventListener('input', ()=>{ bpmLabel.textContent = bpmSlider.value; if(metroTimer) restartMetro(); });
bpmLabel.textContent = bpmSlider.value;

function metroClick(){
  const ctx = ensureAudioCtx();
  const now = ctx.currentTime;
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.type = 'square';
  osc.frequency.setValueAtTime(1000, now);
  gain.gain.setValueAtTime(Number(metroVol.value), now);
  gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.06);
  osc.connect(gain); gain.connect(ctx.destination);
  osc.start(now); osc.stop(now + 0.07);
}
function startMetro(){
  if(metroTimer) return;
  ensureAudioCtx();
  metroClick();
  metroTimer = setInterval(() => metroClick(), (60000 / Number(bpmSlider.value)));
  metroToggle.textContent = 'Stop Metronome';
  statusText(`Метроном: ${bpmSlider.value} BPM`);
}
function stopMetro(){
  if(metroTimer) clearInterval(metroTimer);
  metroTimer = null;
  metroToggle.textContent = 'Start Metronome';
  statusText('Метроном остановлен');
}
function restartMetro(){ stopMetro(); startMetro(); }
metroToggle.addEventListener('click', ()=>{ if(metroTimer) stopMetro(); else startMetro(); });

/* ---------------------- MIDI ---------------------- */
let midiAccess = null;
const midiBtn = document.getElementById('midiBtn');
const midiLogCheck = document.getElementById('midiLog');

const midiNotesMap = [36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51]; // позиция -> note (can be adjusted)

midiBtn.addEventListener('click', async ()=>{
  if(!navigator.requestMIDIAccess){ statusText('Web MIDI API не поддерживается'); return; }
  try{
    midiAccess = await navigator.requestMIDIAccess();
    statusText('MIDI: доступ получен');
    for(let input of midiAccess.inputs.values()) input.onmidimessage = onMIDIMessage;
    midiAccess.onstatechange = ()=>{ for(let input of midiAccess.inputs.values()) input.onmidimessage = onMIDIMessage; };
  }catch(e){ console.warn(e); statusText('MIDI: не удалось получить доступ'); }
});

function onMIDIMessage(evt){
  const [statusByte, note, velocity] = evt.data;
  const command = statusByte >> 4;
  if(command === 9 && velocity > 0){ // Note On
    const pos = midiNotesMap.indexOf(note);
    if(pos !== -1){
      triggerByIndex(pos, velocity);
    }
    if(midiLogCheck.checked){
      logMIDI(`NoteOn note=${note} vel=${velocity} -> pos=${pos}`);
    }
  } else if((command === 8) || (command === 9 && velocity === 0)){
    if(midiLogCheck.checked) logMIDI(`NoteOff note=${note}`);
  }
}

function logMIDI(txt){
  midiLogBox.style.display = 'block';
  const time = new Date().toLocaleTimeString();
  midiLogBox.innerHTML = `<div>[${time}] ${txt}</div>` + midiLogBox.innerHTML;
  // limit lines
  const lines = midiLogBox.children;
  if(lines.length > 200) midiLogBox.removeChild(midiLogBox.lastChild);
}

/* ---------------------- Helpers ---------------------- */
function statusText(t){ status.textContent = 'Статус: ' + t; }
statusText('Готов — разблокируй аудио, подключи MIDI (по желанию).');

// save on unload (redundant as we save after operations, but keep)
window.addEventListener('beforeunload', ()=>{ saveState(); });

/* ---------------------- Инициализация: render и подписки ---------------------- */
renderPads();
statusText('Загружено — играй мышью/клавиатурой/MIDI. Порядок падов восстанавливается из localStorage.');

/* ---------------------- Примечания ----------------------
- Пользовательские загруженные звуки (через кнопку +) хранятся лишь в сессии (объект URL).
  Для постоянного хранения нужно сохранять файл в IndexedDB/Base64 — могу добавить при запросе.
- Если MIDI-контроллер использует другие номера нот, включи MIDI монитор и нажми пад:
  увидишь note -> поправим midiNotesMap.
------------------------------------------------------------------ */

</script>
</body>
</html>
